## 数据（state,props）发生变化，UI视图的更新原理
### react是借助于虚拟DOM来实现的


### 如果不借助于react，我们该如何实现这一功能？？？
* 1.state 数据
* 2.JSX模板（即render函数返回的那一部分内容）
* 3.数据 + 模板 结合，生成真实的DOM，来显示
* 4.state 发生改变
* 5.数据 + 模板 结合，生成真实的DOM，替换原来的DOM

#### 缺陷：
* 第一次生成一个完整的DOM片段
* 第二次生成一个完整的DOM片段（一小段DOM变化得重新生成整个DOM）
* 第二次生成的DOM替换第一次的DOM，非常耗性能


### 改进一
* 1.state 数据
* 2.JSX模板（即render函数返回的那一部分内容）
* 3.数据 + 模板 结合，生成真实的DOM，来显示
* 4.state 发生改变
* 5.数据 + 模板 结合，生成真实的DOM，`并不直接替换原来的DOM`
* 6.新的DOM和原来的DOM 做对比，找差异
* 7.找出input框发生了变化
* 8.只用新的DOM中的input元素，替换掉老的DOM中的input元素

#### 缺陷：
性能提升不明显（生成了俩次DOM，并且直接用DOM去对比其发生的变化）




### 改进二（接下来分析react关于这一部分的实现原理）
* 1.state 数据
* 2.JSX模板（即render函数返回的那一部分内容）
* 3.生成虚拟DOM（虚拟DOM就是一个JS对象，用它来描述真实的DOM）　　（增加了性能消耗）
    > 虚拟DOM ['div',{id:'abc'},['span',{},'hello world']]
* 4.用虚拟DOM的结构来生成真实的DOM，来显示
    > 真实的DOM <div id="abc"><span>hello world </span></div>
* 5.state 发生改变
* 6.数据 + 模板 结合，生成虚拟DOM， (极大的提升了性能，之前是生成真实的DOM)
    > 虚拟DOM ['div',{id:'abc'},['span',{},'虚拟DOM']]
* 7.比较原始虚拟DOM和新的虚拟DOM的区别，发现是其中的span的内容发生变化（极大的提升了性能，虚拟DOM的比较其实就是JS对象的比较，高效）
* 8.直接操作DOM，改变span中的内容

#### 优点：
* 通过减少`真实DOM的创建`和减少`真实DOM的对比`来提高性能（能用虚拟DOM替代的就用虚拟DOM替代）
* 虚拟DOM的存在使得跨端应用得以实现，比如说React Native 
    > 其可以在浏览器的环境下生成相应的DOM
    > 在APP里边则生成相应的组件（APP没有DOM这个概念）

### setState()为何为异步的  (提高react的性能)
* setState数据变化图 ['./JS图片/setState异步.png']
* 每setState一次，数据都会更新，进而触发render重新渲染

### diff算法比对原理（下方的DOM未做特殊声明即为虚拟DOM）
* 同级DOM进行比对，如果同级DOM不同，则直接把子节点全部删除，重新生成一个真实的DOM，并将其替换
* 如上做法有可能会使真实DOM的复用率降低（比如说就父亲节点不一样，子节点不一样的情况），但是这种做法会使得DOM的比较非常高效（故采用这一种）

### 循环中引入key值
* 提高虚拟DOM的比对性能 ['./JS图片/循环加入key.png]

### 为啥最好不要用索引作为key值(保持key值的稳定)
* 如果用索引作为key,当数据变化的时候，数据的索引也会发生变化，这样便失去了引入key值的意义



React的特点['./JS图片/对于React的理解及思考.png']

